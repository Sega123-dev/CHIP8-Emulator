# CHIP8 emulator

CH8 is a programming language used for making CHIP8 programs,they were made in the 60s and 70s.It was interpreted and used as a replacement of languages like BASIC. It runs on a virtual machine,usually implemented on 4K systems like Cosmac VIP and Telmac 1800.

# Virtual machine specifications

- RAM: 4KB (512bytes reserved for CHIP8 fontset,stack and display refresh). 
- Registers: 16 V0 to VF 16 bit registers.
- Stack: Used to store adresses during subroutines,16 levels.
- Delay timer
- Sound timer
- Hex keyboard with 16 keys
- Display: Monochrome 64x32 scaled 10 times

## Opcode table

CHIP8 has 35 official opcodes.Symbols:
- NNN: address
- NN: 8-bit constant
- N: 4-bit constant
- X and Y: 4-bit register identifier
- PC : Program Counter
- I : 12bit register (For memory address) (Similar to void pointer)
- VN: One of the 16 available variables. N may be 0 to F (hexadecimal)

| Opcode<br>                                                             | Type<br>    | C Pseudocode<br>                                                                | Explanation<br>                                                                                                                                                                                                                                                                                                                                                                                    |
|------------------------------------------------------------------------|-------------|---------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| .mw-parser-output .monospaced{font-family:monospace,monospace}0NNN<br> | Call<br>    | <br>                                                                            | Calls machine code routine (RCA 1802 for COSMAC VIP) at address NNN.  Not necessary for most ROMs.[23]<br>                                                                                                                                                                                                                                                                                         |
| 00E0<br>                                                               | Display<br> | disp_clear()<br>                                                                | Clears the screen.[23]<br>                                                                                                                                                                                                                                                                                                                                                                         |
| 00EE<br>                                                               | Flow<br>    | return;<br>                                                                     | Returns from a subroutine.[23]<br>                                                                                                                                                                                                                                                                                                                                                                 |
| 1NNN<br>                                                               | Flow<br>    | goto NNN;<br>                                                                   | Jumps to address NNN.[23]<br>                                                                                                                                                                                                                                                                                                                                                                      |
| 2NNN<br>                                                               | Flow<br>    | *(0xNNN)()<br>                                                                  | Calls subroutine at NNN.[23]<br>                                                                                                                                                                                                                                                                                                                                                                   |
| 3XNN<br>                                                               | Cond<br>    | if (Vx == NN)<br>                                                               | Skips the next instruction if VX equals NN (usually the next instruction is a jump to skip a code block).[23]<br>                                                                                                                                                                                                                                                                                  |
| 4XNN<br>                                                               | Cond<br>    | if (Vx != NN)<br>                                                               | Skips the next instruction if VX does not equal NN (usually the next instruction is a jump to skip a code block).[23]<br>                                                                                                                                                                                                                                                                          |
| 5XY0<br>                                                               | Cond<br>    | if (Vx == Vy)<br>                                                               | Skips the next instruction if VX equals VY (usually the next instruction is a jump to skip a code block).[23]<br>                                                                                                                                                                                                                                                                                  |
| 6XNN<br>                                                               | Const<br>   | Vx = NN<br>                                                                     | Sets VX to NN.[23]<br>                                                                                                                                                                                                                                                                                                                                                                             |
| 7XNN<br>                                                               | Const<br>   | Vx += NN<br>                                                                    | Adds NN to VX (carry flag is not changed).[23]<br>                                                                                                                                                                                                                                                                                                                                                 |
| 8XY0<br>                                                               | Assig<br>   | Vx = Vy<br>                                                                     | Sets VX to the value of VY.[23]<br>                                                                                                                                                                                                                                                                                                                                                                |
| 8XY1<br>                                                               | BitOp<br>   | Vx |= Vy<br>                                                                    | Sets VX to VX or VY. (bitwise OR operation).[23]<br>                                                                                                                                                                                                                                                                                                                                               |
| 8XY2<br>                                                               | BitOp<br>   | Vx &amp;= Vy<br>                                                                | Sets VX to VX and VY. (bitwise AND operation).[23]<br>                                                                                                                                                                                                                                                                                                                                             |
| 8XY3[a]<br>                                                            | BitOp<br>   | Vx ^= Vy<br>                                                                    | Sets VX to VX xor VY.[23]<br>                                                                                                                                                                                                                                                                                                                                                                      |
| 8XY4<br>                                                               | Math<br>    | Vx += Vy<br>                                                                    | Adds VY to VX. VF is set to 1 when there's an overflow, and to 0 when there is not.[23]<br>                                                                                                                                                                                                                                                                                                        |
| 8XY5<br>                                                               | Math<br>    | Vx -= Vy<br>                                                                    | VY is subtracted from VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VX &gt;= VY and 0 if not).[23]<br>                                                                                                                                                                                                                                               |
| 8XY6[a]<br>                                                            | BitOp<br>   | Vx &gt;&gt;= 1<br>                                                              | Shifts VX to the right by 1, then stores the least significant bit of VX prior to the shift into VF.[b][23]<br>                                                                                                                                                                                                                                                                                    |
| 8XY7[a]<br>                                                            | Math<br>    | Vx = Vy - Vx<br>                                                                | Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY &gt;= VX).[23]<br>                                                                                                                                                                                                                                                              |
| 8XYE[a]<br>                                                            | BitOp<br>   | Vx &lt;&lt;= 1<br>                                                              | Shifts VX to the left by 1, then sets VF to 1 if the most significant bit of VX prior to that shift was set, or to 0 if it was unset.[b][23]<br>                                                                                                                                                                                                                                                   |
| 9XY0<br>                                                               | Cond<br>    | if (Vx != Vy)<br>                                                               | Skips the next instruction if VX does not equal VY. (Usually the next instruction is a jump to skip a code block).[23]<br>                                                                                                                                                                                                                                                                         |
| ANNN<br>                                                               | MEM<br>     | I = NNN<br>                                                                     | Sets I to the address NNN.[23]<br>                                                                                                                                                                                                                                                                                                                                                                 |
| BNNN<br>                                                               | Flow<br>    | PC = V0 + NNN<br>                                                               | Jumps to the address NNN plus V0.[23]<br>                                                                                                                                                                                                                                                                                                                                                          |
| CXNN<br>                                                               | Rand<br>    | Vx = rand() &amp; NN<br>                                                        | Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.[23]<br>                                                                                                                                                                                                                                                                                          |
| DXYN<br>                                                               | Display<br> | draw(Vx, Vy, N)<br>                                                             | Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels. Each row of 8 pixels is read as bit-coded starting from memory location I; I value does not change after the execution of this instruction. As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that does not happen.[23]<br> |
| EX9E<br>                                                               | KeyOp<br>   | if (key() == Vx)<br>                                                            | Skips the next instruction if the key stored in VX(only consider the lowest nibble) is pressed (usually the next instruction is a jump to skip a code block).[23]<br>                                                                                                                                                                                                                              |
| EXA1<br>                                                               | KeyOp<br>   | if (key() != Vx)<br>                                                            | Skips the next instruction if the key stored in VX(only consider the lowest nibble) is not pressed (usually the next instruction is a jump to skip a code block).[23]<br>                                                                                                                                                                                                                          |
| FX07<br>                                                               | Timer<br>   | Vx = get_delay()<br>                                                            | Sets VX to the value of the delay timer.[23]<br>                                                                                                                                                                                                                                                                                                                                                   |
| FX0A<br>                                                               | KeyOp<br>   | Vx = get_key()<br>                                                              | A key press is awaited, and then stored in VX (blocking operation, all instruction halted until next key event, delay and sound timers should continue processing).[23]<br>                                                                                                                                                                                                                        |
| FX15<br>                                                               | Timer<br>   | delay_timer(Vx)<br>                                                             | Sets the delay timer to VX.[23]<br>                                                                                                                                                                                                                                                                                                                                                                |
| FX18<br>                                                               | Sound<br>   | sound_timer(Vx)<br>                                                             | Sets the sound timer to VX.[23]<br>                                                                                                                                                                                                                                                                                                                                                                |
| FX1E<br>                                                               | MEM<br>     | I += Vx<br>                                                                     | Adds VX to I. VF is not affected.[c][23]<br>                                                                                                                                                                                                                                                                                                                                                       |
| FX29<br>                                                               | MEM<br>     | I = sprite_addr[Vx]<br>                                                         | Sets I to the location of the sprite for the character in VX(only consider the lowest nibble). Characters 0-F (in hexadecimal) are represented by a 4x5 font.[23]<br>                                                                                                                                                                                                                              |
| FX33<br>                                                               | BCD<br>     | set_BCD(Vx)<br>*(I+0) = BCD(3);<br>*(I+1) = BCD(2);<br>*(I+2) = BCD(1);<br><br> | Stores the binary-coded decimal representation of VX, with the hundreds digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.[23]<br>                                                                                                                                                                                                              |
| FX55<br>                                                               | MEM<br>     | reg_dump(Vx, &amp;I)<br>                                                        | Stores from V0 to VX (including VX) in memory, starting at address I. The offset from I is increased by 1 for each value written, but I itself is left unmodified.[d][23]<br>                                                                                                                                                                                                                      |
| FX65<br>                                                               | MEM<br>     | reg_load(Vx, &amp;I)<br>                                                        | Fills from V0 to VX (including VX) with values from memory, starting at address I. The offset from I is increased by 1 for each value read, but I itself is left unmodified.[d][23]<br>                                                                                                                                                                                                            |


# Features
- 5 ROMs to test the emulator
- Program menu in terminal for choosing the program
- Booting the program
- Showing graphics
- Sound
- Keyboard input
- Logs of things happening inside the emulator

# How to use it

1. Clone the repository or download the ZIP file containing this repo.
2. Place the ROMs inside the compiler directory(usually the bin folder,depends on the compiler).
3. Build and run the program.
4. In terminal,write the name of the program (it has to be written exactly as written in the menu).
5. Enjoy!

**NOTES**: Controls depends on the game,but usually it is W,S,Q,2,8,4 keys on the keyboard.For more ROMs,visit this repo: [ROMs](https://github.com/dmatlack/chip8/tree/master/roms)
 Some games require less CPU cycles while some of them don't,there is a chance that the game is faster or unplayable because of too much or less cycles.

This emulator works for all the programs in the ROM file.Please keep in mind this is a simulation of an original CHIP8 emulator.This emulator does not support Super-CH8 or other CH8 ROM variations.
# Technologies used:

- *C++* - used for opcodes,timing,graphics,memory.
- *SDL* - used for rendering graphics and input.

# Examples

![Pong](images/pong.png)

![Space Invaders](images/space%20invaders.png)
